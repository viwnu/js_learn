// Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:
// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"

// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:
// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30        // под ключом "age" хранится значение 30
// };
//
// // Для обращения к свойствам используется запись «через точку»:
// // получаем свойства объекта:
// alert( user.name ); // John
// alert( user.age ); // 30
//
// // Значение может быть любого типа. Давайте добавим свойство с логическим значением:
// user.isAdmin = true;
//
// delete user.age;


// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

// let user = {
//   name: "John",
//   age: 30,
//   "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
// };

// let user = {};
//
// // присваивание значения свойству
// user["likes birds"] = true;
//
// // получение значения свойства
// alert(user["likes birds"]); // true
//
// // удаление свойства
// delete user["likes birds"];

// Квадратные скобки также позволяют обратиться к свойству,
// имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

// let key = "likes birds";
//
// // то же самое, что и user["likes birds"] = true;
// user[key] = true;


// Пример
//
// let user = {
//   name: "John",
//   age: 30
// };
//
// let key = prompt("Что вы хотите узнать о пользователе?", "name");
//
// // доступ к свойству через переменную
// alert( user[key] ); // John (если ввели "name")

// Запись «через точку» такого не позволяет:
// let user = {
//   name: "John",
//   age: 30
// };
//
// let key = "name";
// alert( user.key ); // undefined

// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
//
// Пример:
//
// let fruit = prompt("Какой фрукт купить?", "apple");
//
// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };
//
// alert( bag.apple ); // 5, если fruit="apple"

// Мы можем использовать и более сложные выражения в квадратных скобках:
//
// let fruit = 'apple';
// let bag = {
//   [fruit + 'Computers']: 5 // bag.appleComputers = 5
// };

// Функция создает обьект:

// function makeUser(name, age) {
//   return {
//     name: name,
//     age: age
//     // ...другие свойства
//   };
// }
//
// let user = makeUser("John", 30);
// alert(user.name); // John


// Вместо name:name мы можем написать просто name:
//
// function makeUser(name, age) {
//   return {
//     name, // то же самое, что и name: name
//     age   // то же самое, что и age: age
//     // ...
//   };
// }

// Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:
//
// let user = {
//   name,  // тоже самое, что и name:name
//   age: 30
// };

// Мы можем использовать только строки и символы в качестве ключей свойств.
//  Все другие типы данных будут автоматически преобразованы к строке.
//
// let obj = {
//   0: "Тест" // то же самое что и "0": "Тест"
// };
//
// // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
// alert( obj["0"] ); // Тест
// alert( obj[0] ); // Тест (то же свойство)

// Зарезервированные слова разрешено использовать как имена свойств.
//
// let obj = {
//   for: 1,
//   let: 2,
//   return: 3
// };
//
// alert( obj.for + obj.let + obj.return );  // 6

// В принципе, разрешены любые имена свойств, но есть специальное свойство __proto__, которое по историческим причинам имеет особое поведение.
//
// Например, его значение всегда должно быть объектом:
//
// let obj = {};
// obj.__proto__ = 5;
// alert(obj.__proto__); // [object Object], работает не так, как мы ожидали

// Особенность объектов в том, что можно получить доступ к любому свойству.
//  Даже если свойства не существует – ошибки не будет! При обращении к свойству,
//  которого нет, возвращается undefined. Это позволяет просто проверить
//   существование свойства – сравнением его с undefined:
//
// let user = {};
//
// alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

// Также существует специальный оператор "in" для проверки существования свойства в объекте.
// let user = { name: "John", age: 30 };
//
// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:
//
// let user = { age: 30 };
//
// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной key

// in когда свойство существует, но содержит значение undefined:
//
// let obj = {
//   test: undefined
// };
//
// alert( obj.test ); // выведет undefined, значит свойство не существует?
//
// alert( "test" in obj ); // true, свойство существует!

// Цикл «for…in»
// К примеру, давайте выведем все свойства объекта user:
//
// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };
//
// for (let key in user) {
//   // ключи
//   alert( key );  // name, age, isAdmin
//   // значения ключей
//   alert( user[key] ); // John, 30, true
// }

// Упорядочение свойств объекта
// В качестве примера рассмотрим объект с телефонными кодами:
//
// let codes = {
//   "49": "Германия",
//   "41": "Швейцария",
//   "44": "Великобритания",
//   // ..,
//   "1": "США"
// };
//
// for (let code in codes) {
//   alert(code); // 1, 41, 44, 49
// }

// Math.trunc - встроенная функция, которая удаляет десятичную часть
// alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
// alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
// alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное

// С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:
//
// let user = {
//   name: "John",
//   surname: "Smith"
// };
// user.age = 25; // добавим ещё одно свойство
//
// // не целочисленные свойства перечислены в порядке создания
// for (let prop in user) {
//   alert( prop ); // name, surname, age
// }

// let codes = {
//   "+49": "Германия",
//   "+41": "Швейцария",
//   "+44": "Великобритания",
//   // ..,
//   "+1": "США"
// };
//
// for (let code in codes) {
//   alert( +code ); // 49, 41, 44, 1
// }

// Копирование по ссылке
// Одним из фундаментальных отличий объектов от примитивных типов данных является
 // то, что они хранятся и копируются «по ссылке».
// огда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.
//
//  let user = { name: "John" };
//
// let admin = user; // копируется ссылка

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:
//
// let user = { name: 'John' };
//
// let admin = user;
//
// admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
//
// alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"

// Два объекта равны только в том случае, если это один и тот же объект.
//
// Например, две переменные ссылаются на один и тот же объект, они равны:
//
// let a = {};
// let b = a; // копирование по ссылке
//
// alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
// alert( a === b ); // true

// В примере ниже два разных объекта не равны, хотя и оба пусты:
//
// let a = {};
// let b = {}; // два независимых объекта
//
// alert( a == b ); // false

// Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

// Объект, объявленный через const, может быть изменён.
//
// Пример:
//
// const user = {
//   name: "John"
// };
//
// user.age = 25; // (*)
//
// alert(user.age); // 25

// Если же мы попытаемся присвоить user другое значение, то const выдаст ошибку:
//
// const user = {
//   name: "John"
// };
//
// // Ошибка (нельзя переопределять константу user)
// user = {
//   name: "Pete"
// };

// если нам всё же нужно дублировать объект?
// Но если мы действительно этого хотим, то нам нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.
//
// Например так:
//
// let user = {
//   name: "John",
//   age: 30
// };
//
// let clone = {}; // новый пустой объект
//
// // скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }
//
// // теперь в переменной clone находится абсолютно независимый клон объекта.
// clone.name = "Pete"; // изменим в нём данные
//
// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – John.
//
// Кроме того, для этих целей мы можем использовать метод Object.assign.
// Object.assign(dest, [src1, src2, src3...])
// Аргументы dest, и src1, ..., srcN (может быть столько, сколько нужно) являются объектами.
// Метод копирует свойства всех объектов src1, ..., srcN в объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект. После копирования метод возвращает объект dest.
// Например, объединим несколько объектов в один:
//
// let user = { name: "John" };
//
// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };
//
// // копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);
//
// now user = { name: "John", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
//
// let user = { name: "John" };
//
// // свойство name перезапишется, свойство isAdmin добавится
// Object.assign(user, { name: "Pete", isAdmin: true });
//
// // now user = { name: "Pete", isAdmin: true }

// Мы также можем использовать Object.assign для простого клонирования:
//
// let user = {
//   name: "John",
//   age: 30
// };
//
// let clone = Object.assign({}, user);
// Все свойства объекта user будут скопированы в пустой объект, и ссылка на этот
//  объект будет в переменной clone. На самом деле, такое клонирование работает
//   так же, как и через цикл, но короче.

// До сих пор мы предполагали, что все свойства пользователя примитивны. Но свойства могут быть ссылками на другие объекты. Что с ними делать?
//
// Например, есть объект:
//
// let user = {
//   name: "John",
//   sizes: {
//     height: 182,
//     width: 50
//   }
// };
//
// alert( user.sizes.height ); // 182
//
// Клонируем его:
// let user = {
// let clone = Object.assign({}, user);
//
// alert( user.sizes === clone.sizes ); // true, один и тот же объект
//
// // user и clone обращаются к одному sizes
// user.sizes.width++;       // меняем свойство в одном объекте
// alert(clone.sizes.width); // 51, видим результат в другом объекте
//
// Чтобы исправить это, мы должны в цикле клонирования делать проверку, не
//  является ли значение user[key] объектом, и если это так – копируем и его
//   структуру тоже. Это называется «глубокое клонирование».
// мы можем использовать реализацию этого алгоритма из JavaScript-библиотеки
// lodash, метод _.cloneDeep(obj).

// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.
//
// В JavaScript есть много других типов объектов:
//
// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.

// Напишите код, выполнив задание из каждого пункта отдельной строкой:
// let user = {};
// user.name = "John";
// user.surname = "Smith";
// user.name = "Pete";
// delete user.name;
// alert(user.name);

// Напишите функцию isEmpty(obj), которая возвращает true, если у объекта нет свойств, иначе false.
//
// Должно работать так:
//
// let schedule = {};
//
// alert( isEmpty(schedule) ); // true
//
// schedule["8:30"] = "get up";
//
// alert( isEmpty(schedule) ); // false
//
// function isEmpty(obj) {
//   for (let key in obj) {
//     return false;
//   }
//   return true;
// }

// У нас есть объект, в котором хранятся зарплаты нашей команды:
//
// let salaries = {
//   John: 100,
//   Ann: 160,
//   Pete: 130
// }
//
// function sum(salaries) {
//   let sum = 0;
//   for (let key in salaries) {
//     sum += salaries[key];
//   }
//   return sum;
// }
//
// alert(sum({}));
// alert(sum(salaries));

// Создайте функцию multiplyNumeric(obj), которая умножает все числовые свойства объекта obj на 2.
//
// Например:
//
// до вызова функции
// let menu = {
//   width: 200,
//   height: 300,
//   title: "My menu"
// };
//
// multiplyNumeric(menu);
//
// // // после вызова функции
// // menu = {
// //   width: 400,
// //   height: 600,
// //   title: "My menu"
// // };
//
// function multiplyNumeric(menu) {
//   for (let key in menu) {
//     if (typeof menu[key] == 'number') {
//       menu[key] *= 2;
//     };
//   }
// }
//
// for (let key in menu) {
//   alert(key + ": " + menu[key]);
// }
