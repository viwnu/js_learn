// // Примеры методов
// // Для начала давайте научим нашего пользователя user здороваться:
//
// let user = {
//   name: "Джон",
//   age: 30
// };
//
// user.sayHi = function() {
//   alert("Привет!");
// };
//
// user.sayHi(); // Привет!

// Конечно, мы могли бы заранее объявить функцию и использовать её в качестве метода, примерно так:
//
// let user = {
//   // ...
// };
//
// // сначала объявляем
// function sayHi() {
//   alert("Привет!");
// };
//
// // затем добавляем в качестве метода
// user.sayHi = sayHi;
//
// user.sayHi(); // Привет!

// Существует более короткий синтаксис для методов в литерале объекта:
//
// // эти объекты делают одно и то же (одинаковые методы)
//
// user = {
//   sayHi: function() {
//     alert("Привет");
//   }
// };
//
// // сокращённая запись выглядит лучше, не так ли?
// user = {
//   sayHi() { // то же самое, что и "sayHi: function()"
//     alert("Привет");
//   }
// };

// Ключевое слово «this» в методах
// Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).
//
// Например, коду внутри user.sayHi() может понадобиться имя пользователя, которое хранится в объекте user.
//
// Для доступа к информации внутри объекта метод может использовать ключевое слово this.
//
// Значение this – это объект «перед точкой», который использовался для вызова метода.
//
// Например:
//
// let user = {
//   name: "Джон",
//   age: 30,
//
//   sayHi() {
//     // this - это "текущий объект"
//     alert(this.name);
//   }
//
// };
//
// user.sayHi(); // Джон

// Технически также возможно получить доступ к объекту без ключевого слова this, ссылаясь на него через внешнюю переменную (в которой хранится ссылка на этот объект):
//
// let user = {
//   name: "Джон",
//   age: 30,
//
//   sayHi() {
//     alert(user.name); // используем переменную "user" вместо ключевого слова "this"
//   }
//
// };

// Но такой код будет ненадёжным
//
// Это показано ниже:
//
// let user = {
//   name: "Джон",
//   age: 30,
//
//   sayHi() {
//     alert( user.name ); // приведёт к ошибке
//   }
//
// };
//
//
// let admin = user;
// user = null; // обнулим переменную для наглядности, теперь она не хранит ссылку на объект.
//
// admin.sayHi(); // Ошибка! Внутри sayHi() используется user, которая больше не ссылается на объект!
//
// Если мы используем this.name вместо user.name внутри alert, тогда этот код будет работать.

// Значение this вычисляется во время выполнения кода и зависит от контекста.
//
// Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:
//
// let user = { name: "Джон" };
// let admin = { name: "Админ" };
//
// function sayHi() {
//   alert( this.name );
// }
//
// // используем одну и ту же функцию в двух объектах
// user.f = sayHi;
// admin.f = sayHi;
//
// // вызовы функции, приведённые ниже, имеют разное значение this
// // "this" внутри функции является ссылкой на объект, который указан "перед точкой"
// user.f(); // Джон  (this == user)
// admin.f(); // Админ  (this == admin)
//
// admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)
//
// Правило простое: при вызове obj.f() значение this внутри f равно obj. Так что, в приведённом примере это user или admin.

// // У стрелочных функций нет «this»
// // Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
// //
// // Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
//
// let user = {
//   firstName: "Илья",
//   sayHi() {
//     let arrow = () => alert(this.firstName);
//     arrow();
//   }
// };
//
// user.sayHi(); // Илья
// // Это является особенностью стрелочных функций. Они полезны, когда мы на самом
// //  деле не хотим иметь отдельное значение this, а хотим брать его из внешнего контекста.

// let calculator = {
//   read() {
//     this.a = +prompt('Введите a', 0);
//     this.b = +prompt('Введите b', 0);
//   },
//   sum(){
//     return this.a + this.b;
//   },
//   mul(){
//     return this.a * this.b;
//   }
// };
//
// calculator.read();
// alert( calculator.sum() );
// alert( calculator.mul() );

// let ladder = {
//   step: 0,
//   up() {
//     this.step++;
//     return this;
//   },
//   down() {
//     this.step--;
//     return this;
//   },
//   showStep: function() { // показывает текущую ступеньку
//     alert( this.step );
//     return this;
//   }
// };
//
// // ladder.up();
// // ladder.up();
// // ladder.down();
// // ladder.showStep();
//
// // ladder.up().up().down().showStep();
//
// ladder
//   .up()
//   .up()
//   .down()
//   .up()
//   .down()
//   .showStep();
